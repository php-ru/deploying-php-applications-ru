# 1. Автоматизировать, автоматизировать и ещё раз автоматизировать

Я хочу прямо сейчас с самого начала донести до вас, поскольку это является одним из важных принципов в процессе деплоя — **автоматизируйте всё**, если хотите **уменьшить человеческие ошибки**. Если процесс деплоя включает в себя шаги, которые нужно делать вручную, у вас будет не лучший период и точно неизбежно дела будут плохи. Никто не идеален. Люди могут и будут забывать, если им нужно что-то вспомнить.

Автоматический процесс деплоя повысит доверие для человека. Зная о том, что всё будет хорошо — это один из основных факторов безопасности во время деплоя. Конечно, могут возникнуть другие неожиданные проблемы, но с гибким процессом, который включает логирование и уведомления, вы можете расслабиться и выяснить, что пошло не так.

## 1.1 Одна кнопка для управления всем

У вас должна быть **одна кнопка** для отправки кода или **одна** команда для выполнения деплоя вашего приложения. Если вы этого не сделаете, что-то пойдёт не так, и поэтому вам стоит автоматизировать все шаги. Возможно, единственное ручное вмешательство, которое я бы рассмотрел, — это подтверждение вроде *«Are you sure? This will push stuff to production. [N/y]»* (*«Вы уверены? Это действие отправит изменения на продакшен. [N/y]»*). Это может быть смелое заявление, но я и правда в это верю.

Даже если вы единственный разработчик в проекте, и вы деплоите приложение каждый раз, я бы назвал плохой практикой, делать это вручную. Когда дело доходит до команд, деплой становится намного хуже, поскольку, если не все члены команды знакомы с шагами для его выполнения, то они попросту не смогут сделать деплой приложения. Члены команды приходят и уходят, и всякий раз, когда появляется новый разработчик в команде, ему нужно научиться правильно делать деплой. Конечно, для этого может быть документация. Но всякий раз, когда кто-то достаточно знаком с процессом деплоя, он, скорее всего, начнёт деплоить без него.

## 1.2 Пример ручного шага

Давайте рассмотрим пример, где у вас есть номер ревизии ваших ресурсов в коде. Я бы сказал, что это довольно распространённая практика (к сожалению), и я видел подобное использование во многих случаях. Этот номер версии отвечает за отключение кеша в браузере, поскольку после нового деплоя нередко нужно использовать новые версии ресурсов, а браузер кеширует статичные файлы вроде CSS, если их путь не сделать уникальным.

Ревизия ресурсов представляет из себя константу в некотором классе по управлению статическими ресурсами.

{lang=php}
~~~~~~~~
class Assets
{
    const REVISION = 14;

    // [...]
}
~~~~~~~~

Затем она используется в путям к статическим ресурсам примерно таким образом:

{lang=html}
~~~~~~~~
<link rel="stylesheet" type="text/css" href="style.css?v=<?= Assets::REVISION ?>">
~~~~~~~~

Это на самом деле плохие ручные шаги, которые вы могли бы сделать. Показанный ручный шаг легко забыть, так как он требует изменения кода, и если про него забыли, это может послужить неправильной работой приложения для пользователей, поскольку у них в браузере используются кешированные (устаревшие) ресурсы. Ручной шаг, когда вам нужно было бы запустить команду в связи с деплоем, было бы лучше, поскольку это легче для запоминания. Когда у вас уже есть командная строка перед вами, вы более склонны запоминать, что в ней происходит.

Поскольку это требует изменения кода, вероятно, возникнет другая проблема. На середине деплоя перед отправкой изменений на продакшен, вы толлько вспомните про этот шаг. Вы останавливаетесь перед нажатием кнопки с криком «Вот чёрт, номер ревизии ресурсов!». Теперь вам придётся изменять код, фиксировать изменения и отправлять код, делая новый деплой. В идеальном мире вы бы уже объединили ветвь с релизом и отметили её тегом (об этом поговорим во второй главе), так, как бы вы этого достигли этого сейчас? Пересоздали репозиторий, удалили тег, зафиксировали изменения в созданной ветви с релизом снова? Или вы просто делаете коммит и отправляете код, зная, что это сломает [прослеживаемость](http://en.wikipedia.org/wiki/Traceability#Software_development) для этого конкретного деплоя? Это проблема, которая устранится с помощью автоматизации.

## 1.3 Время — это всегда фактор

Возможно, вы склонны говорить, что у вас нет времени на автоматизацию всех тривиальных шагов или команд. Если вы потратите один час на автоматизацию команды, выполнение которой занимает одну секунду, вам придётся выполнить эту команду 3601 раз, прежде чем вы сэкономите время на ней или иными словами окупите данную автоматизацию. Да, я подсчитал. Хотя это правда, я бы сказал, что это не вся правда.

Мы должны учитывать время, затрачиваемое на решение проблем, возникающих при забывании шага или команды. Время, потраченное на чистку. Можете ли вы измерить затраты пользователя, когда приложение ломается или ведёт себя некорректно? Скорее всего, нет. В предыдущем примере вы не можете сказать, сколько времени вы потратите на исправление этой ошибки, и вы не можете сказать, как это повлияет на пользователей. Если проблема вовремя не обнаружена, она может сохраняться в течение длительного времени.
