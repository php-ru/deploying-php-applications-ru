# 1. Автоматизировать, автоматизировать и ещё раз автоматизировать

Я хочу прямо сейчас с самого начала донести до вас, поскольку это является одним из важных принципов в процессе деплоя — **автоматизировать всё**, чтобы **минизировать человеческие ошибки**. Если процесс деплоя включает в себя шаги, которые нужно делать вручную, у вас будет не лучший период и точно неизбежно дела будут плохи. Никто не идеален. Люди могут и будут забывать, если им нужно что-то вспомнить.

Автоматический процесс деплоя повысит доверие для человека. Зная о том, что всё будет хорошо — это один из основных факторов безопасности во время деплоя. Конечно, могут возникнуть другие неожиданные проблемы, но с гибким процессом, который включает логирование и уведомления, вы можете расслабиться и выяснить, что пошло не так.

## 1.1 Одна кнопка для управления всем

У вас должна быть **одна кнопка** для отправки кода или **одна** команда для выполнения деплоя вашего приложения. Если вы этого не сделаете, что-то пойдёт не так, и поэтому вам стоит автоматизировать все шаги. Возможно, единственное ручное вмешательство, которое я бы рассмотрел, — это подтверждение вроде *«Are you sure? This will push stuff to production. [N/y]»* («Вы уверены? Это действие отправит изменения на продакшен. [N/y]»*). Это может быть смелое заявление, но я и правда в это верю.

Даже если вы единственный разработчик в проекте, и вы деплоите приложение каждый раз, я бы сказал, что это плохая практика, делать это вручную. Когда дело доходит до команд, это становится намного хуже, поскольку, если не все члены команды знакомы с шагами деплоя, которые они не смогут выполнить деплой приложения. Члены команды приходят и уходят, и всякий раз, когда приходит новый разработчик в команду, ему нужно научиться правильно делать деплой. Конечно, для этого может быть документация. Но всякий раз, когда кто-то достаточно знаком с процессом деплоя, он, скорее всего, начнет деплоить без него.

## 1.2 Пример ручного шага

Давайте рассмотрим пример, где у вас есть номер ревизии ваших ресурсов в коде. Я бы сказал, что это довольно распространенная практика (к сожалению), и я видел подобное использование во многих случаях. Этот номер версии отвечает за отключение кеша в браузере, поэтому они не продолжают использовать старые версии ресурсов после нового деплоя.

Это определение представляет из себя константу в классе где-то для управления статическими ресурсами.

{lang=php}
~~~~~~~~
class Assets
{
    const REVISION = 14;

    // [...]
}
~~~~~~~~

Затем он применяется к статическим ресурсам примерно таким образом:

{lang=html}
~~~~~~~~
<link rel="stylesheet" type="text/css" href="style.css?v=<?=Assets::REVISION?>">
~~~~~~~~

Это на самом деле плохие ручные шаги, которые вы могли бы сделать. Показанный ручный шаг легко забыть, так как он требует изменения кода, и если про него забыли, это может послужить неправильной работой приложения для пользователей, поскольку у них в браузере используются кешированные (устаревшие) ресурсы. Ручной шаг, когда вам нужно было бы запустить команду в связи с деплоем, было бы лучше, поскольку это легче для запоминания. Когда у вас уже есть командная строка перед вами, вы более склонны запоминать, что в ней происходит.

Поскольку это требует изменения кода, вероятно, возникнет другая проблема. Именно тогда, когда вы вспомните шаг на середине деплоя непосредственно перед отправкой изменений на продакшен. Вы останавливаетесь перед нажатием кнопки с криком «Вот чёрт, номер ревизии ресурсов!». Теперь вам придётся изменять код, фиксировать изменения и отправлять код, делая новый деплой. В идеальном мире вы бы уже объединили ветвь с релизом и отметили тегом её (обсуждается в главе 2), так как бы вы этого достигли сейчас? Пересоздать репозиторий, удалить тег, зафиксировать и создать ветвь с релизом снова? Или вы просто делаете коммит и отправляете код, зная, что это сломает [прослеживаемость](http://en.wikipedia.org/wiki/Traceability#Software_development) для этого конкретного деплоя? Это проблема, которая устранится с помощью автоматизации.

## 1.3 Время — это всегда фактор

Возможно, вы склонны говорить, что у вас нет времени на автоматизацию всех тривиальных шагов или команд. Если вы потратите один час на автоматизацию команды, выполняет которой занимает одну секунду, вам придется выполнить эту команду 3601 раз, прежде чем вы сэкономите время на ней. Да, я выполнил математику. Хотя это правда, я бы сказал, что это не вся правда.

Мы должны учитывать время, затрачиваемое на решение проблем, возникающих при забывании шага или команды. Время, потраченное на чистку. Можете ли вы измерить плохой пользовательский опыт, когда приложение ломается или ведет себя некорректно? Скорее всего, нет. В предыдущем примере вы не можете сказать, сколько времени вы потратите на исправление этой ошибки, и вы не можете сказать, как это повлияет на пользователей. Если проблема вовремя не обнаружена, она может сохраняться в течение длительного времени.
