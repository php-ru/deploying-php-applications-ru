# 3. Окружения

Наличие нескольких окружений для вашего приложения имеет важное значение для качества. Каждое окружение служит определённой цели и тем или иным образом представляет состояние вашего приложения. Когда я говорю об окружении, я имею в виду, где работает ваше приложение — это могут быть отдельные серверы или виртуальные машины. Наличие нескольких окружений, работающих на одном компьютере, не является проблемой, если они разделены, но они не должны в некотором смысле взаимодействовать друг с другом. Если два из ваших окружений используют одну и ту же базу данных или кеширование, вы можете получить неожиданные результаты и даже допустить баги, которых не было с самого начала.

## 3.1 Повторяемость

Когда вам говорят, что у вас «сломанная запись», это не весело, но для вашего окружения это лучшее, что можно было сказать. Самое главное, к чему нужно стремиться в ваших окружениях, — это чтобы они всегда имели одну и ту же настройку, в которой операционная система и программное обеспечение используют одинаковую версию и конфигурацию. И в лучшем случае, это когда они **воспроизводимы с помощью автоматизации**.

Много раз я сталкивался с неожиданным поведением из-за того, что окружения отличались друг от друга. Некоторые операционные системы, например, CentOS, рассматривают имена файлов с учётом регистра, в то время как другие, такие как Ubuntu, относятся к ним без учёта регистра. Это может привести к тому, что файлы не будут прочитаны в вашем приложении. Другой показательный пример — как кодируется/декодируется JSON; некоторые окружения будут кодировать `0` в `"0"` (строчный ноль). Если ваше приложение ожидает целое число, а получит вместо этого строку, то все может пойти не так.

Зная, что ваше приложение будет вести себя одинаково в различных окружениях, это здорово, потому что тогда вам не нужно об этом думать. *Устранение неопределённости* важно для получения уверенности в процессе деплоя.

### Подготовка сервера

Я уже говорил, что эта тема выходит за рамки книги, но я все же хочу коснуться её кратко. Если вы хотите добиться повторяемости в вашем окружении до такой степени, что все ваши окружения одинаковы — вам нужно это. Подготовка сервера автоматизирует вашу среду. Предположим, что вы запускаете новый виртуальный экземпляр или устанавливаете новый сервер, каковы ваши дальнейшие действия? Часто они такие:

* Установить программное обеспечение
* Установить значения конфигурации для программного обеспечения
* Настроить сервис или приложение
* Настроить сервис или приложение
* Запустить сервис или приложение

Если вы сделаете это вручную, вы неизбежно потеряете контроль над тем, как его повторить в будущем. Убедившись в том, что правильные значения установлены в `php.ini` на всех серверах, они никогда не будут находится в поддерживаемом состоянии, пока это будет делаться вручную. Чем больше у вас окружений, тем труднее их поддерживать. Необходимо обновить ограничение на загрузку размера файла на 78 экземплярах сервера? Повеселись. Возможно, поручите это стажёру.

Существует несколько инструментов для автоматической настройки сервера. Наиболее популярными из них являются [Chef](https://www.getchef.com/), [Puppet](http://puppetlabs.com/) и [Ansible](http://www.ansible.com/). Последний недавно приобрёл притягательную силу. Я предлагаю вам ознакомиться со всеми ними и посмотреть, какие проблемы они пытаются решить и как они это делают. Они могут помочь вам перейти на следующий уровень деплоя.

## 3.2 Конфигурация / переменные окружения

Важным аспектом окружений является конфигурация вашего приложения для окружения, в котором оно работает. Разделение кода и конфигурации является частью [12-факторного приложения](https://12factor.net/ru/config), и это объясняет важность этого разделение как:

> Иногда приложения хранят конфигурации как константы в коде. Это нарушение методологии двенадцати факторов, которая требует строгого разделения конфигурации и кода. Конфигурация может существенно различаться между деплоями, код не должен различаться.

Различие между кодом и конфигурацией важно, так как ваше приложение должно работать независимо от конфигурации в вашем репозитории. Они выражают простой, но мощный вопрос к этому, которой состоит в следующем — *можете ли вы в любой момент времени открыть исходный код приложения, не компрометируя при этом какие-либо учётные данные?* Если бы вы могли теоретически сделать это, у вас будет строгое разделение кода и конфигурации, и я покажу вы, как сделать это с помощью простого и удобного инструмента под названием *PHP dotenv*.

Цель состоит в том, чтобы предоставить вашему приложению конфигурацию, которая находится за пределами репозитория, и это могут быть любые важные имена хостов или учётные данные для подключений к базе данных, кешированию или к сторонним сервисам, таким как *S3*, *IronMQ* или *MailChimp*.

### PHP dotenv

Этот инструмент, вероятно, все, что вам нужно для удовлетворения ваших требований конфигурации, он простой, но мощный. Он не требует от вас редактирования каких-либо виртуальных хостов в nginx или Apache, а также добавления или изменения значения конфигурации PHP. Всё, что вам требуется сделать — это создать файл с переменными вида ключ-значение, и он заполняет глобальные переменные `$ _ENV` и `$ _SERVER`, а также делает их доступными через функцию [`getenv()`](http://php.net/manual/ru/function.getenv.php).

Установка осуществляется через Composer:

    composer require vlucas/phpdotenv

Затем вам нужно настроить загрузку конфигурации. В этом примере мы передаём ему `__DIR__`, который пытается найти файл конфигурации в том же каталоге, что и исполняемый файл, но это может быть любым каталогом, в котором хотите хранить файл с конфигурацией:

{lang="php"}
~~~
$dotenv = new Dotenv\Dotenv(__DIR__);
$dotenv->load();
~~~

После этого мы создаём файл с именем `.env` в каталоге, который мы указали, и для примера добавим туда нашу конфигурацию базы данных:

~~~
DATABASE_HOST=localhost
DATABASE_USERNAME=user
DATABASE_PASSWORD=password
~~~

Теперь мы можем получить доступ к этим значениям конфигурации из нашего приложении, в данном случае показано три одинаковых примера, которые вернут *localhost*:

{lang="php"}
~~~
$databaseHost = getenv('DATABASE_HOST');
$databaseHost = $_ENV['DATABASE_HOST'];
$databaseHost = $_SERVER['DATABASE_HOST'];
~~~

Я рекомендую использовать `getenv()` или даже лучше написать функцию-обёртку, которая позволяет передавать значение по умолчанию, если значение конфигурации отсутствует (вдохновлено [env()](https://github.com/laravel/framework/blob/a1dc78820d2dbf207dbdf0f7075f17f7021c4ee8/src/Illuminate/Foundation/helpers.php#L626) у Laravel).

{lang="php"}
<<(code/chapter-3/env-function.php)

Эта функция позволяет получить значение конфигурации или значение по умолчанию при его отсутствии

{lang="php"}
```
$databaseHost = env('DATABASE_HOST', 'localhost');
```

Убедитесь, что ваш файл конфигурации игнорируется в вашем репозитории, так чтобы не было даже коммита этого файла. Помните ту часть, где у вас, по крайней мере теоретически, должна быть возможность открыть приложение с открытым исходным кодом, не раскрывая какие-либо учётные данные.

I> ### Пример конфигурационного файла
I>
I> Для ознакомления и простой настройки создайте пример файла конфигурации, который вы можете скопировать и заменить нужные значения. Создайте `.env.example`, который будет содержать все необходимые ключи, необходимые для работы приложения.

## 3.3 Локальное окружение

Наличие локального окружения разработки — это то, чего следует вам добиваться. Под этим я имею в виду приложение, работающее на вашем фактическом компьютере, а не на централизованном сервере, куда вы получаете доступ через VPN-сервис или что-то подобное. Приятно работать с кодом в любом месте без подключения к интернету.

Я всегда разворачиваю локальное окружение разработки на виртуальной машине с помощью [Vagrant](http://www.vagrantup.com). Это позволяет мне делать всё, что угодно с приложением, и если я испорчу окружение достаточно сильно, я просто уничтожу виртуальную машину и подготовлю её с нуля. Это отлично подходит для тестирования кода в вашем окружении, не беспокоясь о том, чтобы что-то сломать на вашем компьютере или чьём-либо ещё. Например, хотите протестировать своё приложение в другой версии PHP? Установите, протестируйте, сбросьте окружение.

Главное, что вы хотите иметь возможность работать с вашим приложением в любой момент. В локальном окружении вы можете работать в самолёте, пролетая через Атлантический океан, и выполняя команды push/pull, как только подключитесь к Интернету. Если вы окажетесь в ситуации, когда вы зависите от интернет-соединения, вы проклинаете себя, когда у вас его нет.

Воспроизводимость вашего локального окружения — это самый главный инструмент для внедрения новых членов команды в ваш код. Представьте, что вы начинаете с нового задачи, и все, что вы делаете, это выполняете команду `git clone <ваш vagrant-репозиторий>`, а затем `vagrant up`, и вы готовы к работе. Похоже на сон, не так ли? Обычно время тратится на документацию по настройке локального окружения, и эта документация во многом устарела, и никто не хочет брать на себя ответственность за её обновление.

## 3.4 Окружение разработки

Название этого окружения может быть несколько обманчивым и вводить в заблуждение. Здесь не следует ничего разрабатывать, а название происходит из стратегии ветвления, обсуждаемой в [шестой главе «Управление версиями»](#chapter-version-control). Это общая площадка для нового функционала и исправления багов, где весь код, который должен быть общим и может проверен другими, в конечном итоге окажется здесь. Первым шагом после завершения работы над чем-либо в вашем локальном окружении будет, как правило, слияние кода в основную ветку и перенос его в окружение разработки.

Это отличное место для раннего тестирования вами и вашей командой. Дополнительная пара глаз на что-либо на раннем стадии может стать отличным инструментом качества. Просмотр кода (он же код ревью) должен быть выполнен до того, как что-то будет объединено и перенесено в это окружение, поскольку это очень эффективный инструмент для обеспечения качества, обмена знаниями и устранения некоторых очевидных ошибок. Все разработчики будут обладать определёнными знаниями о предметной области, а кто-то ещё может сразу определить, почему ваш код не будет работать с определённой частью приложения.

## 3.5 Промежуточное окружение

Ваше промежуточное (staging) окружение очень важно, и оно должно в максимально возможной степени дублировать ваше продашен-окружение. Именно здесь вы проводите окончательное тестирование своего кода, прежде чем отправляете его в продакшен и приложение дойдёт до пользователей.

Под дубликатом в полной мере я не имею в виду, что он должен подключаться к базе данных на продакшен-сервер, например. Наличие базы данных, которая обновляется в соответствии с базой данной на продакшене каждые 24 часа, достаточно хорошая идея. Имеет ли ваше приложение несколько экземпляров базы данных и, возможно, подключается к кластеру кеша? Это промежуточное окружение также понадобится. Приложение запущено на нескольких узлах за балансировщиком нагрузки? Настройте свою промежуточную среду подобным образом. Помните, **нужно быть как можно ближе к продакшен-окружению**.

Возможность тестирования продакшен-данные иногда необходимо, но будьте предельно осторожны, когда делаете это по понятным причинам. Убедитесь, что вы не тестируете функционал, работа которая может привести к отправке электронной почты пользователям. Ваше промежуточное окружение должно, скорее всего, разрешать только исходящую электронную почту на определённые электронные адреса, принадлежащие сотрудникам вашей команды или компании. Вот простой пример, который разрешает логирование электронной почты, если приложение не находится в продакшен-окружении:

{lang=php}
~~~
function sendEmail ($to, $from, $subject, $message) {
	$productionEnvironment = (getenv('ENVIRONMENT') === 'production');
	$internalEmail = (strstr($to, '@yourapplication.com') !== false);

	if (!$productionEnvironment && !$internalEmail) {
		$log = sprintf(
			'Отправка "%s" электронной почты на %s с %s',
			$subject,
			$to,
			$from
		);
		error_log($log);

		return true;
	}

	$headers = 'From: ' . $from . "\r\n" .
		'Reply-To: ' . $from;

	return mail($to, $subject, $message, $headers);
}
~~~

## 3.6 Продакшен-окружение

Это очевидно, и это сервер обслуживает ваше приложение для ваших конечных пользователей. Будь то один сервер или несколько серверов, находящихся за балансировщиком нагрузки; это конечная точка для ваших пользователей.

Он будет содержать как можно более стабильную кодовую базу с хорошо протестированным кодом и максимально свободен от ошибок. Что нужно сказать здесь, так это то, что **для этого окружения нам нужен отличный процесс деплоя**. Все усилия, которые мы вкладываем в этот процесс, отразятся на качестве и стабильности вашего продакшен-окружения.

## 3.7 Тестовое окружение

Наличие одной или нескольких тестовых окружений не обязательно, но это может принести много преимуществ для вашего приложения. В зависимости от размера вашего приложения, тестирование будет намного проще. Если вы, например, можете настроить тестовое окружение для определённых веток, вы можете легко предоставить доступ для тестировщиков к веткам с определённым функционалом.

Есть кое-что важное для успеха с тестовыми окружениями: скорость и воспроизводимость. Если вы можете без особых усилий создать тестовое окружение и проверить определённую ветку, ваши возможности тестирования резко возрастут. Когда я говорю про скорость, я бы рассмотрел 30 минут или меньше в качестве достаточного количества времени. Больше этого времени, и вы можете начать испытывать слишком большие расхождения в скорости разработки и тестового окружения. Кроме того, если вы не можете обновить тестовое окружение в соответствии с последними изменениями, вряд ли это будет стоить вашего времени. Основной посыл здесь — получить быструю обратную связь по вашему коду и отреагировать на него. Исправьте код, снова отправьте изменения на тестовое окружение, а затем получите новую обратную связь.

## 3.8 Упрощение доступа к серверу

В процессе управления несколькими серверами, вы в конечном итоге захотите сделать доступ к ним быстрее и проще. Прежде всего, создание записей хоста для ваших различных серверов устранит необходимость поиска IP-адресов. Для некоторых серверов вам это не понадобится, поскольку они будут доступны публично через такие домены, как ваше продакшен-окружение. Но даже для вашей продакшен-окружения у вас могут быть серверы для баз данных, балансировки нагрузки, кеширования и т.д., и они могут быть недоступны через общедоступный домен. Но вам все равно придётся обращаться к ним на регулярной основе для обслуживания и отладки, поэтому создайте записи хоста для них.

Во-вторых, это настройка и поддержка вашего конфигурационного файла SSH. В нём вы можете управлять хостами, именами хостов, ключами, портами и всем остальным, что необходимо для упрощения доступа к серверам. Сравните эти команды, и вы поймёте, что вы можете многое получить благодаря использованию подобного файла:

```
ssh -i ~/.ssh/myapp-staging.key staging@123.123.1.9 -p 2223

# вместо этого при использовании файла конфигурации:

ssh myapp-staging
```

Все, что нам нужно, это создать `~/.ssh/config` и добавить нашу конфигурацию для нашего окружения. В предыдущем примере это может выглядеть следующим образом: записи хоста добавляются и расширяются для охвата нескольких окружений:

```
Host myapp-staging
    HostName staging.myapp.com
    Port 2223
    User staging
    IdentityFile ~/.ssh/myapp-staging.key

Host myapp-staging-db
    HostName staging-db.myapp.com
    Port 2223
    User staging
    IdentityFile ~/.ssh/myapp-staging.key

Host myapp-production
    HostName myapp.com
    Port 2224
    User production
    IdentityFile ~/.ssh/myapp-production.key

Host myapp-production-db
    HostName db.myapp.com
    Port 2224
    User production
    IdentityFile ~/.ssh/myapp-production.key
```

Как вы можете видеть, можно определить несколько хостов, и вы можете создать по одному для каждого из ваших серверов, которыми вы часто управляете. Это позволит вам сэкономить много времени на доступе к серверам. Есть ещё много классных примочек, которые вы можете сделать здесь, например, указание хостов с использованием метасимволов и многое другое. Вы можете продолжить чтение [справочного руководства по ssh_config](https://www.freebsd.org/cgi/man.cgi?query=ssh_config&sektion=5).
