# 2. Цели {#chapter-goals}

Я очень надеюсь, что вы решили, что хотите улучшить процесс деплоя. Возможно, именно поэтому вы читаете эту книгу в данный момент. Вам стоит сейчас, вероятно, определить несколько моментов. Прямо сейчас задайте себе вопросы, в каком положении ваши дела, и что вы бы хотели изменить. Это основополагающие вопросы для достижения целей — между тем, где вы сейчас находитесь и там, где, наверное, назначили себе несколько целей; так же всегда важно чувствовать то, что вы чего-то достигли. Это начинает казаться вроде книги самопомощи, но я, конечно, говорю о том, какой сейчас у вас процесс деплоя и каким вы хотите его видеть.

У нас есть кое-что, с чем нам нужно разобраться, прежде чем мы перейдём к фактическому списку целей. Понимание причин различных частей поможет вам лучше видеть общую картину происходящего.

## 2.1 Как обычно это начинается

Сделайте глубокий вдох и представьте себе тихое озеро в вашем сознании. Нет, я просто шучу, перестаньте это делать. Это пока не книга из серии «помоги себе сам».

Поскольку процесс деплоя подобен любому другому процессу в цикле разработки программного обеспечения, он будет созревать определённым образом. Обычно он начинается в примерно похожем месте. В этом месте много разработчиков, и он будет продолжать наблюдать, как многие другие разработчики проходят мимо. Я хочу показать людям, что это за место и почему вам следует стараться избегать его. Основная причина, по которой это место плохое, — это то, что *по окончанию* всему конец. Я понимаю, что я только что сказал, что начало в конце, но позвольте мне объяснить, что я имею в виду, прежде чем вы назовёте меня идиотом.

Обычно приложение начинается с идеи. Затем кое-какое отображение идеи (как в уме, так и в реальности). Тогда, возможно, какой-то дизайн и, конечно, определённый код. После чего первая бета-версия готова к выпуску. Ничего себе, это было быстро, ну да ладно. Вот успех, вы получили минимальный жизнеспособный продукт! На этом этапе люди останавливаются и думают: «Ах да, нам нужен какой-то хостинг», и вот кто-то с кредитными картами оплачивает его, а разработчику поручается задеплоить туда код. Конечно, это не проблема для разработчика, но, как правило, на эту часть не будет акцентировано много внимания. Инструменты для деплоя использоваться не будут и ни о какой автоматизации не может быть и речи. Я не говорю, что это касается всего проекта, но это довольно часто встречается у большинства проектов.

Вы видите проблему здесь? **Деплой в большинстве случаев — последнее, о чём думают люди**. Про него многие считают, что им просто нужно просто это сделать, и большинство из них не встанут с постели раньше понедельника, потому что они так сильно захотелось создать великолепный процесс деплоя. Обычно вместо этого будет «исправить это по ходу работы», процесс с быстрыми и грязными исправлениями. Это то, что я обычно называю *деплоем клейкой ленты* (*duct tape deployment*), и да, вы можете процитировать меня в этом. Это больше чем, чаще думают, что мужчина или женщина, или кто-то ещё захочет задеплоить, но они не смогут. Сначала им нужно будет спросить «армию из одного мужчины или женщины, которые делали деплой» относительно того, как это делается, узнать пароли, какие пути доступа используются, где находится база данных, и все остальное, что нужно для деплоя. Эффективно? Нет. Жизнеспособно? Нет.

Нам нужно начать с того, чтобы деплой стал важной частью работы наших приложений. Он должен быть для нашего приложения как поддерживающий и воспитывающий родитель. Вы позволили бы вашему ребёнку отправиться в первый день учёбы без вас? Конечно нет. Школьной системе в Америке очень нравится закон под названием *No Child Left Behind Act* (*Ни одного отстающего ребёнка*), и я хотел бы предложить похожее — *No Application Left Behind Act*, то есть своего рода акт, при котором ни одно приложение не остановились в разработке из-за плохого процесса деплоя. Возможно, это была плохая аналогия, поскольку у них в Америке действительно паршивая система образования. Но я надеюсь, что в любом случае я высказал свою точку зрения.

## 2.2 Зрелость {#maturity}

В течение срока жизни вашего приложения процесс деплоя, я надеюсь, скорее всего, будет зрелым. То, что он созревает, обычно хорошо, и где-то в процессе работы кто-то, вероятно, поймёт, что нужно предпринять шаги для улучшения приложения. Каким образом он будет созревать, как правило, происходит в соответствии со следующим списком, но может быть не в строго таком порядке:

* Документация
* Автоматизация
* Проверка
* Уведомление
* Тесты
* Инструменты
* Мониторинг

**Документация**. Обычно это происходит, когда осуществляется переход от одного человека, который делал деплой к нескольким другим, которые будут деплоить. Это будет естественный шаг, так как процесс деплоя, скорее всего, будет иметь ручные шаги, поэтому вы не сможете развернуть без документации. Где-то документ или что-то подобное в конечном итоге будет описывать различные шаги, которые необходимо выполнить для деплоя.

**Автоматизация**. Несколько людей не деплоят, однако документация устаревает из-за несоответствия. Даже если все шаги руководства хорошо документированы, произойдёт непредвиденное событие, выходящее за рамки документации. В таких случаях это закончится на армии деплоя, состоящей из мужчины/женщины, поскольку у них есть все ответы. Ответ и решение конкретно этой проблемы — автоматизация. Это должно быть скромное усилие, чтобы, в конце концов, автоматизировать все в этом процессе.

**Проверка**. Теперь процесс деплоя достаточно автоматизирован, чтобы каждый мог деплоить в согласованном порядке. Но все ещё он может быть сломан самыми разными путями, поэтому автоматизация требует изменений с целью реализации обработки ошибок, чтобы мы могли убедиться, что этапы выполняются корректно. Деплой может быть прерван, если какой-либо шаг автоматизации завершится с ошибкой и отобразит соответствующее сообщение для человека, который разбирается, что произошло не так.

**Уведомление**. С действующей проверкой деплоя обычно реализуют уведомление определённых людей при ошибке деплоя. Неудачный деплой может быть катастрофическим, и отправка на продакшен ошибочных изменений также может быть доставить большие неприятности. Уведомление о успешном процессе деплоя (ветви, коммита и т.д.) может принести такую же полезную информацию, как и при неудачном деплое.

**Инструменты**. Редко бывает, что процесс деплоя будет использовать инструменты с самого начала. Стабильный процесс работает в большинстве случаев, однако его трудно расширить, поэтому инструменты, скорее всего, будут использоваться. Добавление команд для запуска с помощью инструмента деплоя, как правило, намного проще, чем изменение скрипта автоматизации, что оставит скрипты устаревшими и заменит их. Они также часто заменяют часть документации, поскольку более или менее документируют себя сами, если будут выполнены правильно.

**Мониторинг**. Это шаг, который на самом деле немногие достигнут и, безусловно, более *неплохо бы его иметь*, чем *обязательно он нужен*. Речь идёт о мониторинге того, как приложение и его окружения реагируют на деплой. Мониторинг может контролировать использование ЦП, использование памяти или операций ввода-вывода. Если деплой увеличивает использование памяти на 30%, у вас может возникнуть большая проблема. Таким образом, целью здесь является мониторинг и уведомление о больших отклонениях по определённым ключевым показателям.

## 2.3 Гибкость

Мир вокруг нас, как разработчиков программного обеспечения, становится все более гибким. Я говорю о мире [гибкой методологии разработки] (hhttps://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%B1%D0%BA%D0%B0%D1%8F_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F_%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8), а не о обычном внешнем мире, где люди пьют латте и беспокоятся о своих ипотечных кредитах. Все больше и больше компаний присоединяются к гибкой методологии и по достаточно веской причине. К гибкой методологии входят такие замечательные практики как разработка на основе поведения (BDD), разработка через тестирование (TDD), парное программирование, непрерывная интеграция, спринты, пользовательские истории и кросс-функциональные команды — и это не весь список.

> Agile: "Характеризуется быстротой, мягкостью и лёгкостью движения; шустрый."

Это очень хорошо, потому что вы хотите, чтобы ваш цикл разработки программного обеспечения был быстрым, лёгким и адаптируемым, где вы работаете с небольшим шагом и быстро реагируете на обратную связь через итерацию. В начале 2001 года группа очень умных людей собралась вместе, чтобы поговорить о методах лёгкой разработки, и в конечном итоге они пришли к публикации [Agile-манифеста разработки программного обеспечения](http://agilemanifesto.org/iso/ru/manifesto.html), вот основная его часть:

> Мы постоянно открываем для себя более совершенные методы разработки программного обеспечения, занимаясь разработкой непосредственно и помогая в этом другим. Благодаря проделанной работе мы смогли осознать, что:

> **Люди и взаимодействие** важнее процессов и инструментов
>
> **Работающий продукт** важнее исчерпывающей документации
>
> **Сотрудничество с заказчиком** важнее согласования условий контракта
>
> **Готовность к изменениям** важнее следования первоначальному плану
>
> То есть, не отрицая важности того, что справа, мы всё-таки больше ценим то, что слева.
>
> *Kent Beck, James Grenning, Robert C. Martin, Mike Beedle, Jim Highsmith, Steve Mellor, Arie van Bennekum, Andrew Hunt, Ken Schwaber, Alistair Cockburn, Ron Jeffries, Jeff Sutherland, Ward Cunningham, Jon Kern, Dave Thomas, Martin Fowler, Brian Marick © 2001, вышеперечисленные авторы. Текст манифеста может свободно копироваться в любой форме, но только полностью, включая это уведомление.*

Это действительно весьма интересно, и если вы посмотрите на то, что ценится то, что слева — это люди, гибкость и скорость. Гибкость и скорость фактической разработки и людей связана как с людьми, создающими программное обеспечение, так и с людьми, использующими программное обеспечение.

Теперь вы можете сказать, что я много говорил о **процессе** деплоя, и в манифесте чётко говорится, что он отдаёт предпочтение людям и взаимодействиям, а не процессам и инструментам. Да, это правда; однако в нем также указывается, что в позициях справа есть своя ценность, и я считаю, что процесс деплоя необходим для поддержки реального гибкого процесса разработки. Основой гибкости разработки программного обеспечения является итерация, способность быстро адаптироваться и реагировать на отзывы людей. Как вы сможете сделать это эффективно без хорошего процесса деплоя? Если вы последовательно создаёте функционал и тратите на это два часа, а затем тратите два часа на её деплой, это разве гибко? Я бы сказал, нет. Даже если деплой занимает «всего» 30 минут, вам нужна уверенность в нём, и если есть много ручных шагов или вы не можете сделать быстрый и лёгкий откат, это то, о чём говорит agile?

## 2.4 План марафона

Что может быть лучше во всем этом, чем сравнение с марафоном? В мире agile вы работаете спринтами, и если вы планируете процесс деплоя для текущего спринта, ваш план будет очень недальновидным и ситуативным. Если вы ожидаете, что ваше приложение будет жить дольше, чем несколько спринтов, вам необходим план на будущее. Так что планируйте марафон, а не короткий спринт.

Выполнение оценок так же сложно, независимо от того, делаете ли вы это для своего времени разработки или будущего вашего приложения. Это особенно верно в мире agile, где быстрая адаптация к обратной связи может изменить направление такого будущего в одно мгновение. Но нам нужно, по крайней мере, хотя бы попытаться это сделать. Попробуйте представить, где ваше приложение может оказаться. Придумав нескольких сценариев, которые могут произойти, не повредит вам.

Скажем, вы деплоите своё приложение на VPS с ограниченными ресурсами и не имеете реальных возможностей быстро масштабировать его. Есть вероятность, что ваше приложение будет упомянуто на Hacker News, Reddit, Product Hunt или Slashdot, из-за чего трафик взлетит до небес, и что потом? Имеется ли у вас процесс деплоя, который достаточно хорош для быстрого перемещения вашего приложения на новый хостинг-провайдер? Поддерживает ли приложение и процесс деплоя выполнение на нескольких узлах? Просто чтобы внести ясность, я не говорю, что вам нужно при создании процесса деплоя учитывать всевозможные сценарии, поскольку это будет крайне неэффективно. Я говорю, что вам стоило бы держать такие сценарии в голове, пока вы планируете и реализуете с подобным мышлением «если произойдёт X, могу ли я легко изменить его, чтобы адаптироваться ему». Процесс деплоя также должен быть гибким, чтобы можно было быстро и легко вносить изменения.

## 2.5 Циклы релизов

Вы можете написать, сколько кода вам нравится, но если он не будет выпущен, то в нём нет никакой ценности. Вы и ваша команда должна должны быть нацелены на то, как часто вы хотите отправлять код в продакшен. Будь то один раз в месяц или четыре раза в день, если у вас есть цель и план для этого. Если у вас нет цели, вы не можете достичь чего-то. Поэтому поставьте цель, если у вас её нет, и попытайтесь достичь её. Знание текущего и желаемого цикла релизов важно для планирования вашего процесса деплоя.

I> Под «выпущен» относительно кода я имею в виду его деплой — от завершения работы над определённым функционалом в локальной окружении до его отправки на продакшен-сервер.

Есть несколько способов, с помощью которых мы отправляем код, и различные его модели можно суммировать следующим образом:

* Я закончил, можно деплоить.
* Новая версия сделана, можно деплоить.
* X времени прошло, можно деплоить.
* Я отправил изменения в репозиторий, можно деплоить.

Это, конечно, упрощено, и на практике многие из этих вариантов используются. Но давайте обсудим каждый из них по отдельности, чтобы узнать, что он представляет из себя.

**Я закончил, можно деплоить.**. Мы могли бы назвать это *деплой функционала* или *вынужденный деплой* в зависимости от того, как мы к этому относимся. Это типичная модель, когда есть один или несколько разработчиков приложения. Это ситуативный тип деплоя, когда вы закончили и протестировали свой функционал, который вы теперь деплоите. Я думаю, что это очень недооценённый тип деплоя, если вы можете быть уверенным в том, что не отправляете изменения, сделанные кем-то другим. Почему мы должны ждать ритуального деплоя? Если вы контролируете версию с хорошей стратегией ветвления, подобные несистематические типы деплоя, безусловно, возможны. Для более крупных команд и приложений я бы не рекомендовал так делать.

**Новая версия сделана, можно деплоить**. Это произойдёт, когда ваше приложение будет готово для новой версии, как незначительной, так большой. Смысл здесь в том, что кода для деплоя, вероятно, будет много, поскольку разработка версии проходит в течение значительного периода времени. Я бы избегал такой модели деплоя, как чумы, когда это касается веб-приложений. Одним из больших преимуществ веб-приложений — это возможность быстро его изменять, не выполняя шаги сборки и зная, что ваши пользователи получат приложение с обновлённым кодом. В интернете вы отправляете свой код, после чего у вашего пользователя нет выбора, использовать прежнюю версию приложения или только что отправленную с новыми изменениями. Зачем вообще делать деплой только после готовности небольшой версии? Если у вас это так, то одна из причин этого может заключаться в том, что процесс деплоя сложный. Исправьте и прекратите отправлять изменения подобным образом.

**X времени прошло, можно деплоить**. Если ваша команда работает спринтами, вероятно, таким образом вы деплоите. Всякий раз, когда спринт завершён, вы делаете деплой. Количество времени между деплоем может варьироваться в зависимости от того, какие долгие у вас спринты, конечно, и основное внимание здесь заключается в том, что развёртывание происходит периодически, например каждую неделю по понедельникам. В принципе я не против такой модели деплоя, при условии, что у вас разумные продолжительности спринта. Если у вас скрипт длится три месяца, это может быть плохо, и вам нужно посмотреть, почему вы именно так решили делать. Но если у вас есть спринт, возможно, продолжительностью в 1-2 недели, попробуйте так деплоить.

**Я отправил изменения в репозиторий, можно деплоить**. Также известен как *непрерывный деплой (continuous deployment)*. Ах, единорог разворачивается. Происходит деплой, когда один или несколько коммитов отправляются в репозиторий. Это достигается путём (по крайней мере, так должно быть) очень сложной системой автоматизации с тестированием и мониторингом. Эта тема, как вы можете это сделать, непростая, и я не буду здесь её объяснять.

Один важный момент в возможности постоянного деплоя — это жизнь, а не мечта. У очень немногих будет время, знания и терпение для создания полного процесса непрерывного деплоя. Однако это то, к чему мы можем стремиться, даже если вы не хотите непрерывного деплоя. Построение культуры, среды и процесса, где это возможно, принесёт вам огромную пользу. Наличие правильных инструментов для автоматизации, мониторинга и т.д. — никогда не повредит. Если бы у вас было все это и вы просто отключили переключатель, который автоматически всё деплоит, у вас должно быть было бы ощущение блаженства и спокойствия. У вас получилось.

## 2.6 Технический долг и деградация ПО

Технический долг и программная деградация — это что-то хорошо известное и обсуждаемое в сообществе разработчиков, но эти концепции могут быть применены не только к коду. Мы должны позаботиться о нашем деплое так же, как и нашем коде. Когда бессистемный процесс деплоя будет создан, мы немедленно начинаем накапливать технический долг, а когда он начинает разлагаться, у появляется **доставка испорченного кода (shipping rot)**. Проблема с этим видом долга заключается в том, что он больше, чем обычно, экспоненциальный и самодостаточный. Вы слышали о [теории разбитых окон](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D1%82%D1%8B%D1%85_%D0%BE%D0%BA%D0%BE%D0%BD)? Краткий пересказ, для тех, кто не в курсе: когда люди видят, что у здания есть разбитое окно, они перестают меньше заботиться о его сохранности и втягиваются по спирали, т.е. разбивают другие окна! Это отлично применимо и к разработке программного обеспечения, где устаревший код остаётся устаревшим и кодом с ошибками, и порождает больше плохого кода. То же самое касается нашего процесса деплоя: плохой процесс останется плохим или он со временем ухудшится. Если вы можете остановить это самое первое окно от повреждения или быстро его заменить на новое, все остальные будут заботиться о том, чтобы он оставался таким же целым. Имея определённые цели — это отличный инструмент для быстрого решения проблемы с этим разбитым окном, и если вы в какой-то момент увидите много разбитых окон, вам, возможно, стоит восстановить их все одним большим махом.

## 2.7 Список целей {#goals-list}

Мы можем сформировать цели в ненумерованном списке, поскольку всем нравится чёткий и краткий список, не так ли? При чтении списка попробуйте задуматься о том, где вы сейчас находитесь в разных целях.

* Автоматизированный
* Отзывчивый
* Атомарный
* Обратимый
* Простой
* Быстрый
* Независимый

**Автоматизированный**. Вы прочитали первую главу? Если нет, сделайте это. Отсутствие автоматизированного процесса — это корень всего зла.

**Отзывчивый**. Хороший процесс деплоя отвечает тому, что происходит. Если где-то происходит ошибка, она должна прервать процесс деплоя и уведомить вас или нужных людей. Тихое выполнение шагов в цепочке может быть очень разрушительным для вашего приложения.

**Атомарный**. Ничто при деплое не должно нарушить работу вашего приложения, и вам следует соблюдать концепцию завершения сборки перед тем, как приложение будет использоваться конечным пользователем. Переход между предыдущей и новой сборкой приложения должен быть максимально быстрым.

**Простой**. Каждый должен понимать процесс деплоя и использовать его. Каждый должен чувствовать себя уверенно и комфортно с ним. Это касается и деплоя, внесения изменений или расширения процесса.

**Обратимый**. Потому что это звучит лучше, чем «возможность откатить изменения». Возможность отката так же важна, как и деплой ваших изменений, и этот обратимый процесс также должен соответствовать списку целей.

**Быстрый**. Вы хотите, чтобы он был быстрым, потому что скорость — это ключ к возможности часто деплоить. Быстрые откаты в сочетании с быстрыми деплоями — ещё один главный аспект, который говорит о доверии. Если что-то ломается, вы можете легко откатиться и исправить ситуацию без того напряжения, зная, что продакшен находится в неисправном состоянии.

**Независимый**. Создание процесса деплоя, зависящего от его окружения, может быть разрушительным. Например, возможность деплоя только на Amazon Web Services будет отличной, пока вы не захотите сменить провайдера. Приложение должно быть успешно развёрнуто в любом месте, и его не должно волновать, кто или что делает деплой.
